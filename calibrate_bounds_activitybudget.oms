import _file_.model._

def outside(v: Seq[Double], min: Double, max: Double) = v.count(v => v < min | v > max).toDouble / v.size
def outsideP(v: Seq[Double], target: Double, p: Double = 0.5) = outside(v, target - (target * p), target + (target * p))

def dailyTravelDistanceFit(v: Seq[Double]) = outsideP(v, 769)
def totalEnergyExpenditureFit(v: Seq[Double]) = outsideP(v, 1476)
def totalEnergyIntakeFit(v: Seq[Double]) = outsideP(v, 3015)

def travelDistFit(d: Seq[Array[Double]]) = dailyTravelDistanceFit(d.map(_(5)))
def energyExpenditureFit(d: Seq[Array[Double]]) = totalEnergyExpenditureFit(d.map(_(10)))
def energyIntakeFit(d: Seq[Array[Double]]) = totalEnergyIntakeFit(d.map(_(9)))

def energyFit(d: Seq[Array[Double]]) =
  Seq(
   dailyTravelDistanceFit(d.map(_(5))),
   totalEnergyExpenditureFit(d.map(_(10))),
   totalEnergyIntakeFit(d.map(_(9)))
  ).average
 

def frequencyOfSwayFit(d: Seq[Double]) = outsideP(d, 20.2)  
def frequencyOfBrachiateFit(d: Seq[Double]) = outsideP(d, 51.2)
def frequencyOfWalkFit(d: Seq[Double]) = outsideP(d, 12.5)
def frequencyOfClimbFit(d: Seq[Double]) = outsideP(d,10.5)
def frequencyOfDescentFit(d: Seq[Double]) = outsideP(d, 5.5)

def frequencyOfMoveFit(d: Seq[Array[Double]]) =
  Seq(
    frequencyOfSwayFit(d.map(_(1))),
    frequencyOfBrachiateFit(d.map(_(2))),
// in this world setting, orangutan would not walk <-   frequencyOfWalkFit(d.map(_(0))),
    frequencyOfClimbFit(d.map(_(3))),
    frequencyOfDescentFit(d.map(_(4))),
  ).average


def feedingBudgetFit(d: Seq[Double]) = outsideP(d, 50.6)
def travelingBudgetFit(d: Seq[Double]) = outsideP(d, 16.6)
def restingBudgetFit(d: Seq[Double]) = outsideP(d, 31.3)

def feedingBudgetF(d: Seq[Array[Double]]) = feedingBudgetFit(d.map(_(6)))
def travelingBudgetF(d: Seq[Array[Double]]) = travelingBudgetFit(d.map(_(7)))
def restingBudgetF(d: Seq[Array[Double]]) = restingBudgetFit(d.map(_(8)))

def budgetFit(d: Seq[Array[Double]]) =
  Seq(
    feedingBudgetFit(d.map(_(6))),
    travelingBudgetFit(d.map(_(7))),
    restingBudgetFit(d.map(_(8)))
  ).average

val replicate = 
  Replication(
    evaluation = model, 
    seed = seed, 
    sample = 10,
    aggregation = Seq(
      walk aggregate median, 
      sway aggregate median,
      brachiation aggregate median,
      climb aggregate median, 
      descent aggregate median, 
      travelDistance aggregate median,
      feedingBudget aggregate median, 
      travellingBudget aggregate median,
      restingBudget aggregate median,
      totalEnergyIntake aggregate median,
      energyExpenditure aggregate median
    )
  )

val resultLine = Val[Array[Double]]

val tupleTask = ScalaTask("""
  val resultLine = 
    Array(walk, sway, brachiation, climb, descent, travelDistance, feedingBudget, travellingBudget, restingBudget, totalEnergyIntake, energyExpenditure) 
""") set (
  (inputs, outputs) += (walk, sway, brachiation, climb, descent, travelDistance, feedingBudget, travellingBudget, restingBudget, totalEnergyIntake, energyExpenditure), 
  outputs += (resultLine)
)

val env =
  SLURMEnvironment(
    "widyastu",
    "taurus.hrsk.tu-dresden.de",
    time = 4 hour,
    memory = 6000 megabytes,
    openMOLEMemory = 5000 megabytes,
    reservation = "p_peatfire_288",
    nodes = 1,
    cpuPerTask = 3,
    //nTasks = 12,
    threads = 6
  )

NSGA2Evolution(
  evaluation = replicate -- tupleTask,
  genome = Seq(
    bodyWeight in (30.0 to 45.0),
    energyIntake in (0.1 to 10.0),
    energyGain in (1.0 to 400.0),
   // initialSatiation in (-500.0 to 500.0),
    basalEnergy in (1.0 to 1.5),
    brachiationSpeed in (0.5 to 2.0),
    swaySpeed in (0.5 to 2.0),
    climbSpeed in (0.5 to 2.0),
    descentSpeed in (0.5 to 2.0),
    walkSpeed in (0.5 to 1.0)
  ),
  reject = "climbSpeed > (descentSpeed - 0.2)",
  objective = Seq(
    resultLine aggregate (feedingBudgetF _) as "feedingBudget",
    resultLine aggregate (travelingBudgetF _) as "travelingBudget",
    resultLine aggregate (restingBudgetF _) as "restingBudget"
  ),
  parallelism = 300,
  termination = 500000,
  stochastic = Stochastic(seed = seed, sample = 50),
  distribution = Island(5 minutes)
) hook (workDirectory / "results_07_06_1123new", filter = Seq(resultLine), frequency = 50) on env by 6


